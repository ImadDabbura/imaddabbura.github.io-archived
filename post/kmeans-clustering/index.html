<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.4.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Imad Dabbura">

  
  
  
    
  
  <meta name="description" content="Overview
 Clustering Kmeans Algorithm Implementation Applications  Geyser&rsquo;s Eruptions Segmentation Image Compression   Evaluation Methods Drawbacks Conclusion  Clustering is one of the most common exploratory data analysis technique used to get an intuition about the structure of the data. It can be defined as the task of identifying subgroups in the data such that data points in the same subgroup (cluster) are very similar while data points in different clusters are very different.">

  
  <link rel="alternate" hreflang="en-us" href="https://imaddabbura.github.io/post/kmeans-clustering/">

  


  

  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.css" integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ==" crossorigin="anonymous">
    

    

  

  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:400,400italic,700|Roboto+Mono&display=swap">
  

  
  
  
  <link rel="stylesheet" href="/css/academic.min.e8b81181bd18f58d8990b40dc8a5e4b8.css">

  

  
  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-127825273-1', 'auto');
      ga('set', 'anonymizeIp', true);
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  
  

  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon-32.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://imaddabbura.github.io/post/kmeans-clustering/">

  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@ImadPhd">
  <meta property="twitter:creator" content="@ImadPhd">
  
  <meta property="og:site_name" content="Imad Dabbura">
  <meta property="og:url" content="https://imaddabbura.github.io/post/kmeans-clustering/">
  <meta property="og:title" content="K-means Clustering - Algorithm, Applications, Evaluation Methods, and Drawbacks | Imad Dabbura">
  <meta property="og:description" content="Overview
 Clustering Kmeans Algorithm Implementation Applications  Geyser&rsquo;s Eruptions Segmentation Image Compression   Evaluation Methods Drawbacks Conclusion  Clustering is one of the most common exploratory data analysis technique used to get an intuition about the structure of the data. It can be defined as the task of identifying subgroups in the data such that data points in the same subgroup (cluster) are very similar while data points in different clusters are very different."><meta property="og:image" content="https://imaddabbura.github.io/post/kmeans-clustering/featured.png">
  <meta property="twitter:image" content="https://imaddabbura.github.io/post/kmeans-clustering/featured.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2018-09-11T00:00:00&#43;00:00">
    
    <meta property="article:modified_time" content="2018-09-11T00:00:00&#43;00:00">
  

  

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
<script>
  window.addEventListener("load", function(){
    window.cookieconsent.initialise({
      "palette": {
        "popup": {
          "background": "#2962ff",
          "text": "#fff"
        },
        "button": {
          "background": "#fff",
          "text": "#2962ff"
        }
      },
      "theme": "classic",
      "content": {
        "message": "This website uses cookies to ensure you get the best experience on our website.",
        "dismiss": "Got it!",
        "link": "Learn more",
        "href": "https://cookies.insites.com"
      }
    })});
</script>



  





  <title>K-means Clustering - Algorithm, Applications, Evaluation Methods, and Drawbacks | Imad Dabbura</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Imad Dabbura</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#projects"><span>Projects</span></a>
        </li>

        
        

        

        
        
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/til/"><span>Today I Learned</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/files/resume.pdf"><span>Resume</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  <article class="article" itemscope itemtype="http://schema.org/Article">

  




















  
  
    
  


<div class="article-container pt-3">
  <h1 itemprop="name">K-means Clustering - Algorithm, Applications, Evaluation Methods, and Drawbacks</h1>

  

  



<meta content="2018-09-11 00:00:00 &#43;0000 UTC" itemprop="datePublished">
<meta content="2018-09-11 00:00:00 &#43;0000 UTC" itemprop="dateModified">

<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    <time>Sep 11, 2018</time>
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    18 min read
  </span>
  

  
  
  
  <span class="middot-divider"></span>
  <a href="/post/kmeans-clustering/#disqus_thread"></a>
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/categories/data-science/">Data Science</a>, <a href="/categories/machine-learning/">Machine Learning</a></span>
  

  
    
<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=https://imaddabbura.github.io/post/kmeans-clustering/&amp;text=K-means%20Clustering%20-%20Algorithm,%20Applications,%20Evaluation%20Methods,%20and%20Drawbacks" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https://imaddabbura.github.io/post/kmeans-clustering/&amp;t=K-means%20Clustering%20-%20Algorithm,%20Applications,%20Evaluation%20Methods,%20and%20Drawbacks" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook-f"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=K-means%20Clustering%20-%20Algorithm,%20Applications,%20Evaluation%20Methods,%20and%20Drawbacks&amp;body=https://imaddabbura.github.io/post/kmeans-clustering/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=https://imaddabbura.github.io/post/kmeans-clustering/&amp;title=K-means%20Clustering%20-%20Algorithm,%20Applications,%20Evaluation%20Methods,%20and%20Drawbacks" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://web.whatsapp.com/send?text=K-means%20Clustering%20-%20Algorithm,%20Applications,%20Evaluation%20Methods,%20and%20Drawbacks%20https://imaddabbura.github.io/post/kmeans-clustering/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=https://imaddabbura.github.io/post/kmeans-clustering/&amp;title=K-means%20Clustering%20-%20Algorithm,%20Applications,%20Evaluation%20Methods,%20and%20Drawbacks" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>


  

</div>

  














</div>


<div class="article-header article-container featured-image-wrapper mt-4 mb-4" style="max-width: 720px; max-height: 686px;">
  <div style="position: relative">
    <img src="/post/kmeans-clustering/featured_hu673474fbf6320cc4b498f5995efa3afc_542210_720x0_resize_lanczos_3.png" alt="" class="featured-image">
    
  </div>
</div>



  <div class="article-container">

    <div class="article-style" itemprop="articleBody">
      <!-- raw HTML omitted -->
<p><strong>Overview</strong></p>
<ul>
<li><a href="#introduction">Clustering</a></li>
<li><a href="#kmeans">Kmeans Algorithm</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#application">Applications</a>
<ul>
<li><a href="#2dexample">Geyser&rsquo;s Eruptions Segmentation</a></li>
<li><a href="#imagecompression">Image Compression</a></li>
</ul>
</li>
<li><a href="#evaluation">Evaluation Methods</a></li>
<li><a href="#drawbacks">Drawbacks</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p><strong>Clustering</strong> is one of the most common exploratory data analysis technique used to get an intuition about the structure of the data. It can be defined as the task of identifying subgroups in the data such that data points in the same subgroup (cluster) are very similar while data points in different clusters are very different. In other words, we try to find homogeneous subgroups within the data such that data points in each cluster are as similar as possible according to a similarity measure such as euclidean-based distance or correlation-based distance. The decision of which similarity measure to use is application-specific.</p>
<p>Clustering analysis can be done on the basis of features where we try to find subgroups of samples based on features or on the basis of samples where we try to find subgroups of features based on samples. We&rsquo;ll cover here clustering based on features. Clustering is used in market segmentation; where we try to fin  d customers that are similar to each other whether in terms of behaviors or attributes, image segmentation/compression; where we try to group similar regions together, document clustering based on topics, etc.</p>
<p>Unlike supervised learning, clustering is considered an unsupervised learning method since we don&rsquo;t have the ground truth to compare the output of the clustering algorithm to the true labels to evaluate its performance. We only want to try to investigate the structure of the data by grouping the data points into distinct subgroups.</p>
<p>In this post, we will cover only <strong>Kmeans</strong> which is considered as one of the most commonly used clustering algorithms due to its simplicity.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p><strong>Kmeans</strong> algorithm is an iterative algorithm that tries to partition the dataset into <em>K</em> pre-defined distinct non-overlapping subgroups (clusters) where each data point belongs to <strong>only one group</strong>. It tries to make the inter-cluster data points as similar as possible while also keeping
the clusters as different (far) as possible. It assigns data points to a cluster such that the sum of the squared distance between the data points and the cluster&rsquo;s centroid (arithmetic mean of all the data points that belong to that cluster) is at the minimum. The less variation we have within clusters, the more homogeneous (similar) the data points are within the same cluster.</p>
<p>The way kmeans algorithm works is as follows:</p>
<ol>
<li>Specify number of clusters <em>K</em>.</li>
<li>Initialize centroids by first shuffling the dataset and then randomly selecting <em>K</em> data points for the centroids without replacement.</li>
<li>Keep iterating until there is no change to the centroids. i.e assignment of data points to clusters isn&rsquo;t changing.
<ul>
<li>Compute the sum of the squared distance between data points and all centroids.</li>
<li>Assign each data point to the closest cluster (centroid).</li>
<li>Compute the centroids for the clusters by taking the average of all data points that belong to each cluster.</li>
</ul>
</li>
</ol>
<p>The approach kmeans follows to solve the problem is called <strong>Expectation-Maximization</strong>. The E-step is assigning the data points to the closest cluster. The M-step is computing the centroid of each cluster. Below is a break down of how we can solve it mathematically (feel free to skip it).</p>
<p>The objective function is:</p>
<p>$$J = \sum_{i = 1}^{m}\sum_{k = 1}^{K}w_{ik}|x^i - \mu_k|^2\tag{1}$$</p>
<p>where $w_{ik} = 1$ for data point $x^i$ if it belongs to cluster <em>k</em>; otherwise, $w_{ik} = 0$. Also, $\mu_k$ is the centroid of $x^i$&rsquo;s cluster.</p>
<p>It&rsquo;s a minimization problem of two parts. We first minimize J w.r.t. $w_{ik}$ and treat $\mu_k$ fixed. Then we minimize J w.r.t. $\mu_k$ and treat $w_{ik}$ fixed. Technically speaking, we differentiate J w.r.t. $w_{ik}$ first and update cluster assignments  (<em>E-step</em>). Then we differentiate J w.r.t. $\mu_{k}$ and recompute the centroids after the cluster assignments from previous step  (<em>M-step</em>). Therefore, E-step is:</p>
<p>$$\frac{\partial J}{\partial w_{ik}} = \sum_{i = 1}^{m}\sum_{k = 1}^{K}|x^i - \mu_k|^2$$
$$\Rightarrow \begin{equation} w_{ik} = \begin{cases} 1 &amp; \text{if $k = arg min_j\ |x^i - \mu_j|^2$} \\\
0 &amp; \text{otherwise}. \end{cases} \end{equation}\tag{2}$$
In other words, assign the data point $x^i$ to the closest cluster judged by its sum of squared distance from cluster&rsquo;s centroid.</p>
<p>And M-step is:</p>
<p>$$\ \frac{\partial J}{\partial \mu_k} = 2\sum_{i = 1}^{m}w_{ik}(x^i - \mu_k) = 0$$
$$\Rightarrow \mu_k = \frac{\sum_{i = 1}^{m}w_{ik}x^i}{\sum_{i = 1}^{m}w_{ik}}\tag{3}$$
Which translates to recomputing the centroid of each cluster to reflect the new assignments.</p>
<p>Few things to note here:</p>
<ul>
<li>Since clustering algorithms including kmeans use distance-based measurements to determine the similarity between data points, it&rsquo;s recommended to standardize the data to have a mean of zero and a standard deviation of one since almost always the features in any dataset would have different units of measurements such as age vs income.</li>
<li>Given kmeans iterative nature and the random initialization of centroids at the start of the algorithm, different initializations may lead to different clusters since kmeans algorithm may <em>stuck in a local optimum and may not converge to global optimum</em>. Therefore, it&rsquo;s recommended to run the algorithm using different initializations of centroids and pick the results of the run that that yielded the lower sum of squared distance.</li>
<li>Assignment of examples isn&rsquo;t changing is the same thing as no change in within-cluster variation:</li>
</ul>
<p>$$\frac{1}{m_k}\sum_{i = 1}^{m_k}|x^i - \mu_{c^k}|^2\tag{4}$$</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>We&rsquo;ll use simple implementation of kmeans here to just illustrate some concepts. Then we will use <code>sklearn</code> implementation that is more efficient take care of many things for us.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> numpy.linalg <span style="color:#f92672">import</span> norm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Kmeans</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;Implementing Kmeans algorithm.&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, n_clusters, max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>, random_state<span style="color:#f92672">=</span><span style="color:#ae81ff">123</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>n_clusters <span style="color:#f92672">=</span> n_clusters
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>max_iter <span style="color:#f92672">=</span> max_iter
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>random_state <span style="color:#f92672">=</span> random_state
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">initializ_centroids</span>(self, X):
</span></span><span style="display:flex;"><span>        np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>RandomState(self<span style="color:#f92672">.</span>random_state)
</span></span><span style="display:flex;"><span>        random_idx <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>permutation(X<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>        centroids <span style="color:#f92672">=</span> X[random_idx[:self<span style="color:#f92672">.</span>n_clusters]]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> centroids
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">compute_centroids</span>(self, X, labels):
</span></span><span style="display:flex;"><span>        centroids <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros((self<span style="color:#f92672">.</span>n_clusters, X<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>n_clusters):
</span></span><span style="display:flex;"><span>            centroids[k, :] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>mean(X[labels <span style="color:#f92672">==</span> k, :], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> centroids
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">compute_distance</span>(self, X, centroids):
</span></span><span style="display:flex;"><span>        distance <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros((X<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>], self<span style="color:#f92672">.</span>n_clusters))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>n_clusters):
</span></span><span style="display:flex;"><span>            row_norm <span style="color:#f92672">=</span> norm(X <span style="color:#f92672">-</span> centroids[k, :], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            distance[:, k] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>square(row_norm)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> distance
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_closest_cluster</span>(self, distance):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>argmin(distance, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">compute_sse</span>(self, X, labels, centroids):
</span></span><span style="display:flex;"><span>        distance <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(X<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>n_clusters):
</span></span><span style="display:flex;"><span>            distance[labels <span style="color:#f92672">==</span> k] <span style="color:#f92672">=</span> norm(X[labels <span style="color:#f92672">==</span> k] <span style="color:#f92672">-</span> centroids[k], axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>sum(np<span style="color:#f92672">.</span>square(distance))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fit</span>(self, X):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>centroids <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>initializ_centroids(X)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>max_iter):
</span></span><span style="display:flex;"><span>            old_centroids <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>centroids
</span></span><span style="display:flex;"><span>            distance <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>compute_distance(X, old_centroids)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>labels <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>find_closest_cluster(distance)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>centroids <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>compute_centroids(X, self<span style="color:#f92672">.</span>labels)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> np<span style="color:#f92672">.</span>all(old_centroids <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>centroids):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>error <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>compute_sse(X, self<span style="color:#f92672">.</span>labels, self<span style="color:#f92672">.</span>centroids)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">predict</span>(self, X):
</span></span><span style="display:flex;"><span>        distance <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>compute_distance(X, self<span style="color:#f92672">.</span>centroids)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>find_closest_cluster(distance)
</span></span></code></pre></div><p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>kmeans algorithm is very popular and used in a variety of applications such as market segmentation, document clustering, image segmentation and image compression, etc. The goal usually when we undergo a cluster analysis is either:</p>
<ol>
<li>Get a meaningful intuition of the structure of the data we&rsquo;re dealing with.</li>
<li>Cluster-then-predict where different models will be built for different subgroups if we believe there is a wide variation in the behaviors of different subgroups. An example of that is clustering patients into different subgroups and build a model for each subgroup to predict the probability of the risk of having heart attack.</li>
</ol>
<p>In this post, we&rsquo;ll apply clustering on two cases:</p>
<ul>
<li>Geyser eruptions segmentation (2-D dataset).</li>
<li>Image compression.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>We&rsquo;ll first implement the kmeans algorithm on 2D dataset and see how it works. The dataset has 272 observations and 2 features. The data covers the waiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA. We will try to find <em>K</em> subgroups within the data points and group them accordingly. Below is the description of the features:</p>
<ul>
<li>eruptions (float): Eruption time in minutes.</li>
<li>waiting (int):  Waiting time to next eruption.</li>
</ul>
<p>Let&rsquo;s plot the data first:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Modules</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> matplotlib.image <span style="color:#f92672">import</span> imread
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> seaborn <span style="color:#66d9ef">as</span> sns
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.datasets.samples_generator <span style="color:#f92672">import</span> (make_blobs,
</span></span><span style="display:flex;"><span>                                                make_circles,
</span></span><span style="display:flex;"><span>                                                make_moons)
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.cluster <span style="color:#f92672">import</span> KMeans, SpectralClustering
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.preprocessing <span style="color:#f92672">import</span> StandardScaler
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.metrics <span style="color:#f92672">import</span> silhouette_samples, silhouette_score
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">%</span>matplotlib inline
</span></span><span style="display:flex;"><span>sns<span style="color:#f92672">.</span>set_context(<span style="color:#e6db74">&#39;notebook&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>style<span style="color:#f92672">.</span>use(<span style="color:#e6db74">&#39;fivethirtyeight&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> warnings <span style="color:#f92672">import</span> filterwarnings
</span></span><span style="display:flex;"><span>filterwarnings(<span style="color:#e6db74">&#39;ignore&#39;</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Import the data</span>
</span></span><span style="display:flex;"><span>df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_csv(<span style="color:#e6db74">&#39;../data/old_faithful.csv&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plot the data</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>scatter(df<span style="color:#f92672">.</span>iloc[:, <span style="color:#ae81ff">0</span>], df<span style="color:#f92672">.</span>iloc[:, <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#39;Eruption time in mins&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;Waiting time to next eruption&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;Visualization of raw data&#39;</span>);
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/geyser_raw.png" >

<img src="/img/kmeans/geyser_raw.png" >
</a>

</figure>

<p>We&rsquo;ll use this data because it&rsquo;s easy to plot and visually spot the clusters since its a 2-dimension dataset. It&rsquo;s obvious that we have 2 clusters. Let&rsquo;s standardize the data first and run the kmeans algorithm on the standardized data with $K = 2$.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Standardize the data</span>
</span></span><span style="display:flex;"><span>X_std <span style="color:#f92672">=</span> StandardScaler()<span style="color:#f92672">.</span>fit_transform(df)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Run local implementation of kmeans</span>
</span></span><span style="display:flex;"><span>km <span style="color:#f92672">=</span> Kmeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>km<span style="color:#f92672">.</span>fit(X_std)
</span></span><span style="display:flex;"><span>centroids <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>centroids
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plot the clustered data</span>
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>scatter(X_std[km<span style="color:#f92672">.</span>labels <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>], X_std[km<span style="color:#f92672">.</span>labels <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>            c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;cluster 1&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>scatter(X_std[km<span style="color:#f92672">.</span>labels <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], X_std[km<span style="color:#f92672">.</span>labels <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>            c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blue&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;cluster 2&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>scatter(centroids[:, <span style="color:#ae81ff">0</span>], centroids[:, <span style="color:#ae81ff">1</span>], marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;*&#39;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">300</span>,
</span></span><span style="display:flex;"><span>            c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;r&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;centroid&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlim([<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylim([<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#39;Eruption time in mins&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;Waiting time to next eruption&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#39;Visualization of clustered data&#39;</span>, fontweight<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;bold&#39;</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_aspect(<span style="color:#e6db74">&#39;equal&#39;</span>);
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/geyser_clustered.png" >

<img src="/img/kmeans/geyser_clustered.png" >
</a>

</figure>

<p>The above graph shows the scatter plot of the data colored by the cluster they belong to. In this example, we chose $K = 2$. The symbol <strong>&rsquo;*&rsquo;</strong> is the centroid of each cluster. We can think of those 2 clusters as geyser had different kinds of behaviors under different scenarios.</p>
<p>Next, we&rsquo;ll show that different initializations of centroids may yield to different results. I&rsquo;ll use 9 different <code>random_state</code> to change the initialization of the centroids and plot the results. The title of each plot will be the sum of squared distance of each initialization.</p>
<p>As a side note, this dataset is considered very easy and converges in less than 10 iterations. Therefore, to see the effect of random initialization on convergence, I am going to go with 3 iterations to illustrate the concept. However, in real world applications, datasets are not at all that clean and nice!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>n_iter <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">16</span>))
</span></span><span style="display:flex;"><span>ax <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>ravel(ax)
</span></span><span style="display:flex;"><span>centers <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_iter):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Run local implementation of kmeans</span>
</span></span><span style="display:flex;"><span>    km <span style="color:#f92672">=</span> Kmeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>                max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>                random_state<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000</span>, size<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    km<span style="color:#f92672">.</span>fit(X_std)
</span></span><span style="display:flex;"><span>    centroids <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>centroids
</span></span><span style="display:flex;"><span>    centers<span style="color:#f92672">.</span>append(centroids)
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>scatter(X_std[km<span style="color:#f92672">.</span>labels <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>], X_std[km<span style="color:#f92672">.</span>labels <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>                  c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;cluster 1&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>scatter(X_std[km<span style="color:#f92672">.</span>labels <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], X_std[km<span style="color:#f92672">.</span>labels <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>                  c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blue&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;cluster 2&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>scatter(centroids[:, <span style="color:#ae81ff">0</span>], centroids[:, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>                  c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;r&#39;</span>, marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;*&#39;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">300</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;centroid&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>set_xlim([<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>set_ylim([<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>legend(loc<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;lower right&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>km<span style="color:#f92672">.</span>error<span style="color:#e6db74">:</span><span style="color:#e6db74">.4f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>set_aspect(<span style="color:#e6db74">&#39;equal&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout();
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/geyser_multiple.png" >

<img src="/img/kmeans/geyser_multiple.png" >
</a>

</figure>

<p>As the graph above shows that we only ended up with two different ways of clusterings based on different initializations. We would pick the one with the lowest sum of squared distance.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>In this part, we&rsquo;ll implement kmeans to compress an image. The image that we&rsquo;ll be working on is 396 x 396 x 3. Therefore, for each pixel location we would have 3 8-bit integers that specify the red, green, and blue intensity values. Our goal is to reduce the number of colors to 30 and represent (compress) the photo using those 30 colors only. To pick which colors to use, we&rsquo;ll use kmeans algorithm on the image and treat every pixel as a data point. That means reshape the image from height x width x channels to (height * width) x channel, i,e we would have 396 x 396 = 156,816 data points in 3-dimensional space which are the intensity of RGB. Doing so will allow us to represent the image using the 30 centroids for each pixel and would significantly reduce the size of the image by a factor of 6. The original image size was 396 x 396 x 24 = 3,763,584 bits; however, the new compressed image would be 30 x 24 + 396 x 396 x 4 = 627,984 bits. The huge difference comes from the fact that we&rsquo;ll be using centroids as a lookup for pixels&rsquo; colors and that would reduce the size of each pixel location to 4-bit instead of 8-bit.</p>
<p>From now on we will be using <code>sklearn</code> implementation of kmeans. Few thing to note here:</p>
<ul>
<li><code>n_init</code> is the number of times of running the kmeans with different centroid&rsquo;s initialization. The result of the best one will be reported.</li>
<li><code>tol</code> is the within-cluster variation metric used to declare convergence.</li>
<li>The default of <code>init</code> is <strong>k-means++</strong> which is supposed to yield a better results than just random initialization of centroids.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Read the image</span>
</span></span><span style="display:flex;"><span>img <span style="color:#f92672">=</span> imread(<span style="color:#e6db74">&#39;images/my_image.jpg&#39;</span>)
</span></span><span style="display:flex;"><span>img_size <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>shape
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Reshape it to be 2-dimension</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>reshape(img_size[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> img_size[<span style="color:#ae81ff">1</span>], img_size[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Run the Kmeans algorithm</span>
</span></span><span style="display:flex;"><span>km <span style="color:#f92672">=</span> KMeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>km<span style="color:#f92672">.</span>fit(X)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use the centroids to compress the image</span>
</span></span><span style="display:flex;"><span>X_compressed <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>cluster_centers_[km<span style="color:#f92672">.</span>labels_]
</span></span><span style="display:flex;"><span>X_compressed <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>clip(X_compressed<span style="color:#f92672">.</span>astype(<span style="color:#e6db74">&#39;uint8&#39;</span>), <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">255</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Reshape X_recovered to have the same dimension as the original image 128 * 128 * 3</span>
</span></span><span style="display:flex;"><span>X_compressed <span style="color:#f92672">=</span> X_compressed<span style="color:#f92672">.</span>reshape(img_size[<span style="color:#ae81ff">0</span>], img_size[<span style="color:#ae81ff">1</span>], img_size[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plot the original and the compressed image next to each other</span>
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, figsize <span style="color:#f92672">=</span> (<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">8</span>))
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>imshow(img)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#39;Original Image&#39;</span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>imshow(X_compressed)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#39;Compressed Image with 30 colors&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ax <span style="color:#f92672">in</span> fig<span style="color:#f92672">.</span>axes:
</span></span><span style="display:flex;"><span>    ax<span style="color:#f92672">.</span>axis(<span style="color:#e6db74">&#39;off&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout();
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/image_compression.png" >

<img src="/img/kmeans/image_compression.png" >
</a>

</figure>

<p>We can see the comparison between the original image and the compressed one. The compressed image looks close to the original one which means we&rsquo;re able to retain the majority of the characteristics of the original image. With smaller number of clusters we would have higher compression rate at the expense of image quality. As a side note, this image compression method is called <em>lossy data compression</em> because we can&rsquo;t reconstruct the original image from the compressed image.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>Contrary to supervised learning where we have the ground truth to evaluate the model&rsquo;s performance, clustering analysis doesn&rsquo;t have a solid evaluation metric that we can use to evaluate the outcome of different clustering algorithms. Moreover, since kmeans requires <em>k</em> as an input and doesn&rsquo;t learn it from data, there is no right answer in terms of the number of clusters that we should have in any problem. Sometimes domain knowledge and intuition may help but usually that is not the case. In the cluster-predict methodology, we can evaluate how well the models are performing based on different <em>K</em> clusters since clusters are used in the downstream modeling.</p>
<p>In this post we&rsquo;ll cover two metrics that may give us some intuition about <em>k</em>:</p>
<ul>
<li>Elbow method</li>
<li>Silhouette analysis</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Run the Kmeans algorithm and get the index of data points clusters</span>
</span></span><span style="display:flex;"><span>sse <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>list_k <span style="color:#f92672">=</span> list(range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> list_k:
</span></span><span style="display:flex;"><span>    km <span style="color:#f92672">=</span> KMeans(n_clusters<span style="color:#f92672">=</span>k)
</span></span><span style="display:flex;"><span>    km<span style="color:#f92672">.</span>fit(X_std)
</span></span><span style="display:flex;"><span>    sse<span style="color:#f92672">.</span>append(km<span style="color:#f92672">.</span>inertia_)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plot sse against k</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(list_k, sse, <span style="color:#e6db74">&#39;-o&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;Number of clusters *k*&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;Sum of squared distance&#39;</span>);
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/elbow.png" >

<img src="/img/kmeans/elbow.png" >
</a>

</figure>

<p>The graph above shows that $k = 2$ is not a bad choice. Sometimes it&rsquo;s still hard to figure out a good number of clusters to use because the curve is monotonically decreasing and may not show any elbow or has an obvious point where the curve starts flattening out.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p><strong>Silhouette analysis</strong> can be used to determine the degree of separation between clusters. For each sample:</p>
<ul>
<li>Compute the average distance from all data points in the same cluster ($a^i$).</li>
<li>Compute the average distance from all data points in the closest cluster ($b^i$).</li>
<li>Compute the coefficient:</li>
</ul>
<p>$$\frac{b^i - a^i}{max(a^i, b^i)}$$</p>
<p>The coefficient can take values in the interval [-1, 1].</p>
<ul>
<li>If it is 0 &ndash;&gt; the sample is very close to the neighboring clusters.</li>
<li>If it is 1 &ndash;&gt; the sample is far away from the neighboring clusters.</li>
<li>If it is -1 &ndash;&gt; the sample is assigned to the wrong clusters.</li>
</ul>
<p>Therefore, we want the coefficients to be as big as possible and close to 1 to have a good clusters. We&rsquo;ll use here geyser dataset again because its cheaper to run the silhouette analysis and it is actually obvious that there is most likely only two groups of data points.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, k <span style="color:#f92672">in</span> enumerate([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]):
</span></span><span style="display:flex;"><span>    fig, (ax1, ax2) <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    fig<span style="color:#f92672">.</span>set_size_inches(<span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Run the Kmeans algorithm</span>
</span></span><span style="display:flex;"><span>    km <span style="color:#f92672">=</span> KMeans(n_clusters<span style="color:#f92672">=</span>k)
</span></span><span style="display:flex;"><span>    labels <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>fit_predict(X_std)
</span></span><span style="display:flex;"><span>    centroids <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>cluster_centers_
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Get silhouette samples</span>
</span></span><span style="display:flex;"><span>    silhouette_vals <span style="color:#f92672">=</span> silhouette_samples(X_std, labels)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Silhouette plot</span>
</span></span><span style="display:flex;"><span>    y_ticks <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    y_lower, y_upper <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i, cluster <span style="color:#f92672">in</span> enumerate(np<span style="color:#f92672">.</span>unique(labels)):
</span></span><span style="display:flex;"><span>        cluster_silhouette_vals <span style="color:#f92672">=</span> silhouette_vals[labels <span style="color:#f92672">==</span> cluster]
</span></span><span style="display:flex;"><span>        cluster_silhouette_vals<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>        y_upper <span style="color:#f92672">+=</span> len(cluster_silhouette_vals)
</span></span><span style="display:flex;"><span>        ax1<span style="color:#f92672">.</span>barh(range(y_lower, y_upper), cluster_silhouette_vals, edgecolor<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;none&#39;</span>, height<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        ax1<span style="color:#f92672">.</span>text(<span style="color:#f92672">-</span><span style="color:#ae81ff">0.03</span>, (y_lower <span style="color:#f92672">+</span> y_upper) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, str(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>        y_lower <span style="color:#f92672">+=</span> len(cluster_silhouette_vals)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Get the average silhouette score and plot it</span>
</span></span><span style="display:flex;"><span>    avg_score <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>mean(silhouette_vals)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#f92672">.</span>axvline(avg_score, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#f92672">.</span>set_yticks([])
</span></span><span style="display:flex;"><span>    ax1<span style="color:#f92672">.</span>set_xlim([<span style="color:#f92672">-</span><span style="color:#ae81ff">0.1</span>, <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    ax1<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#39;Silhouette coefficient values&#39;</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#39;Cluster labels&#39;</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#39;Silhouette plot for the various clusters&#39;</span>, y<span style="color:#f92672">=</span><span style="color:#ae81ff">1.02</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Scatter plot of data colored with labels</span>
</span></span><span style="display:flex;"><span>    ax2<span style="color:#f92672">.</span>scatter(X_std[:, <span style="color:#ae81ff">0</span>], X_std[:, <span style="color:#ae81ff">1</span>], c<span style="color:#f92672">=</span>labels)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#f92672">.</span>scatter(centroids[:, <span style="color:#ae81ff">0</span>], centroids[:, <span style="color:#ae81ff">1</span>], marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;*&#39;</span>, c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;r&#39;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">250</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#f92672">.</span>set_xlim([<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    ax2<span style="color:#f92672">.</span>set_xlim([<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    ax2<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#39;Eruption time in mins&#39;</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#39;Waiting time to next eruption&#39;</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#39;Visualization of clustered data&#39;</span>, y<span style="color:#f92672">=</span><span style="color:#ae81ff">1.02</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#f92672">.</span>set_aspect(<span style="color:#e6db74">&#39;equal&#39;</span>)
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>tight_layout()
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>suptitle(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Silhouette analysis using k = </span><span style="color:#e6db74">{</span>k<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>,
</span></span><span style="display:flex;"><span>                 fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>, fontweight<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;semibold&#39;</span>, y<span style="color:#f92672">=</span><span style="color:#ae81ff">1.05</span>);
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/silhouette_2.png" >

<img src="/img/kmeans/silhouette_2.png" >
</a>

</figure>




  




<figure>

  <a data-fancybox="" href="/img/kmeans/silhouette_3.png" >

<img src="/img/kmeans/silhouette_3.png" >
</a>

</figure>




  




<figure>

  <a data-fancybox="" href="/img/kmeans/silhouette_4.png" >

<img src="/img/kmeans/silhouette_4.png" >
</a>

</figure>

<p>As the above plots show, <code>n_clusters=2</code> has the best average silhouette score of around 0.75 and all clusters being above the average shows that it is actually a good choice. Also, the thickness of the silhouette plot gives an indication of how big each cluster is. The plot shows that cluster 1 has almost double the samples than cluster 2. However, as we increased <code>n_clusters</code> to 3 and 4, the average silhouette score decreased dramatically to around 0.48 and 0.39 respectively. Moreover, the thickness of silhouette plot started showing wide fluctuations. The bottom line is: Good <code>n_clusters</code> will have a well above 0.5 silhouette average score as well as all of the clusters have higher than the average score.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>Kmeans algorithm is good in capturing structure of the data if clusters have a spherical-like shape. It always try to construct a nice spherical shape around the centroid. That means, the minute the clusters have a complicated geometric shapes, kmeans does a poor job in clustering the data. We&rsquo;ll illustrate three cases where kmeans will not perform well.</p>
<p>First, kmeans algorithm doesn&rsquo;t let data points that are far-away from each other share the same cluster even though they obviously belong to the same cluster. Below is an example of data points on two different horizontal lines that illustrates how kmeans tries to group half of the data points of each horizontal lines together.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Create horizantal data</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>tile(np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">20</span>), <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>repeat(np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>]), <span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>df <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>c_[X, y]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>km <span style="color:#f92672">=</span> KMeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>km<span style="color:#f92672">.</span>fit(df)
</span></span><span style="display:flex;"><span>labels <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>predict(df)
</span></span><span style="display:flex;"><span>centroids <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>cluster_centers_
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>scatter(X, y, c<span style="color:#f92672">=</span>labels)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlim([<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylim([<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>text(<span style="color:#ae81ff">5.1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;A&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>text(<span style="color:#ae81ff">5.1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;B&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>text(<span style="color:#ae81ff">2.8</span>, <span style="color:#ae81ff">4.1</span>, <span style="color:#e6db74">&#39;C&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_aspect(<span style="color:#e6db74">&#39;equal&#39;</span>)
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/horizontal_cluster.png" >

<img src="/img/kmeans/horizontal_cluster.png" >
</a>

</figure>

<p>Kmeans considers the point &lsquo;B&rsquo; closer to point &lsquo;A&rsquo; than point &lsquo;C&rsquo; since they have non-spherical shape. Therefore, points &lsquo;A&rsquo; and &lsquo;B&rsquo; will be in the same cluster but point &lsquo;C&rsquo; will be in a different cluster. Note the <strong>Single Linkage</strong> hierarchical clustering method gets this right because it doesn&rsquo;t separate similar points).</p>
<p>Second, we&rsquo;ll generate data from multivariate normal distributions with different means and standard deviations. So we would have 3 groups of data where each group was generated from different multivariate normal distribution (different mean/standard deviation). One group will have a lot more data points than the other two combined. Next, we&rsquo;ll run kmeans on the data with $K = 3$ and see if it will be able to cluster the data correctly. To make the comparison easier, I am going to plot first the data colored based on the distribution it came from. Then I will plot the same data but now colored based on the clusters they have been assigned to.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Create data from three different multivariate distributions</span>
</span></span><span style="display:flex;"><span>X_1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>multivariate_normal(mean<span style="color:#f92672">=</span>[<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>], cov<span style="color:#f92672">=</span>[[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]], size<span style="color:#f92672">=</span><span style="color:#ae81ff">75</span>)
</span></span><span style="display:flex;"><span>X_2 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>multivariate_normal(mean<span style="color:#f92672">=</span>[<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">6</span>], cov<span style="color:#f92672">=</span>[[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>]], size<span style="color:#f92672">=</span><span style="color:#ae81ff">250</span>)
</span></span><span style="display:flex;"><span>X_3 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>multivariate_normal(mean<span style="color:#f92672">=</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>], cov<span style="color:#f92672">=</span>[[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>]], size<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>df <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>concatenate([X_1, X_2, X_3])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Run kmeans</span>
</span></span><span style="display:flex;"><span>km <span style="color:#f92672">=</span> KMeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>km<span style="color:#f92672">.</span>fit(df)
</span></span><span style="display:flex;"><span>labels <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>predict(df)
</span></span><span style="display:flex;"><span>centroids <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>cluster_centers_
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plot the data</span>
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>scatter(X_1[:, <span style="color:#ae81ff">0</span>], X_1[:, <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>scatter(X_2[:, <span style="color:#ae81ff">0</span>], X_2[:, <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>scatter(X_3[:, <span style="color:#ae81ff">0</span>], X_3[:, <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>set_aspect(<span style="color:#e6db74">&#39;equal&#39;</span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>scatter(df[:, <span style="color:#ae81ff">0</span>], df[:, <span style="color:#ae81ff">1</span>], c<span style="color:#f92672">=</span>labels)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>scatter(centroids[:, <span style="color:#ae81ff">0</span>], centroids[:, <span style="color:#ae81ff">1</span>], marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;o&#39;</span>,
</span></span><span style="display:flex;"><span>                c<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;white&#34;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">200</span>, edgecolor<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;k&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, c <span style="color:#f92672">in</span> enumerate(centroids):
</span></span><span style="display:flex;"><span>    ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>scatter(c[<span style="color:#ae81ff">0</span>], c[<span style="color:#ae81ff">1</span>], marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;$</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">$&#39;</span> <span style="color:#f92672">%</span> i, s<span style="color:#f92672">=</span><span style="color:#ae81ff">50</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, edgecolor<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;r&#39;</span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_aspect(<span style="color:#e6db74">&#39;equal&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout()
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/random_data.png" >

<img src="/img/kmeans/random_data.png" >
</a>

</figure>

<p>Looks like kmeans couldn&rsquo;t figure out the clusters correctly. Since it tries to minimize the within-cluster variation, it gives more weight to bigger clusters than smaller ones. In other words, data points in smaller clusters may be left away from the centroid in order to focus more on the larger cluster.</p>
<p>Last, we&rsquo;ll generate data that have complicated geometric shapes such as moons and circles within each other and test kmeans on both of the datasets.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Cricles</span>
</span></span><span style="display:flex;"><span>X1 <span style="color:#f92672">=</span> make_circles(factor<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, noise<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>, n_samples<span style="color:#f92672">=</span><span style="color:#ae81ff">1500</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Moons</span>
</span></span><span style="display:flex;"><span>X2 <span style="color:#f92672">=</span> make_moons(n_samples<span style="color:#f92672">=</span><span style="color:#ae81ff">1500</span>, noise<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, X <span style="color:#f92672">in</span> enumerate([X1, X2]):
</span></span><span style="display:flex;"><span>    fig<span style="color:#f92672">.</span>set_size_inches(<span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>    km <span style="color:#f92672">=</span> KMeans(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    km<span style="color:#f92672">.</span>fit(X[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    labels <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>predict(X[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    centroids <span style="color:#f92672">=</span> km<span style="color:#f92672">.</span>cluster_centers_
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>scatter(X[<span style="color:#ae81ff">0</span>][:, <span style="color:#ae81ff">0</span>], X[<span style="color:#ae81ff">0</span>][:, <span style="color:#ae81ff">1</span>], c<span style="color:#f92672">=</span>labels)
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>scatter(centroids[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>], centroids[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;*&#39;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">400</span>, c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;r&#39;</span>)
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>scatter(centroids[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], centroids[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>], marker<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;+&#39;</span>, s<span style="color:#f92672">=</span><span style="color:#ae81ff">300</span>, c<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>suptitle(<span style="color:#e6db74">&#39;Simulated data&#39;</span>, y<span style="color:#f92672">=</span><span style="color:#ae81ff">1.05</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">22</span>, fontweight<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;semibold&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout()
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/circles_wrong.png" >

<img src="/img/kmeans/circles_wrong.png" >
</a>

</figure>

<p>As expected, kmeans couldn&rsquo;t figure out the correct clusters for both datasets. However, we can help kmeans perfectly cluster these kind of datasets if we use kernel methods. The idea is we transform to higher dimensional representation that make the data linearly separable (the same idea that we use in SVMs). Different kinds of algorithms work very well in such scenarios such as <code>SpectralClustering</code>, see below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Cricles</span>
</span></span><span style="display:flex;"><span>X1 <span style="color:#f92672">=</span> make_circles(factor<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, noise<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>, n_samples<span style="color:#f92672">=</span><span style="color:#ae81ff">1500</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Moons</span>
</span></span><span style="display:flex;"><span>X2 <span style="color:#f92672">=</span> make_moons(n_samples<span style="color:#f92672">=</span><span style="color:#ae81ff">1500</span>, noise<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, X <span style="color:#f92672">in</span> enumerate([X1, X2]):
</span></span><span style="display:flex;"><span>    fig<span style="color:#f92672">.</span>set_size_inches(<span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>    sp <span style="color:#f92672">=</span> SpectralClustering(n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, affinity<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;nearest_neighbors&#39;</span>)
</span></span><span style="display:flex;"><span>    sp<span style="color:#f92672">.</span>fit(X[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    labels <span style="color:#f92672">=</span> sp<span style="color:#f92672">.</span>labels_
</span></span><span style="display:flex;"><span>    ax[i]<span style="color:#f92672">.</span>scatter(X[<span style="color:#ae81ff">0</span>][:, <span style="color:#ae81ff">0</span>], X[<span style="color:#ae81ff">0</span>][:, <span style="color:#ae81ff">1</span>], c<span style="color:#f92672">=</span>labels)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>suptitle(<span style="color:#e6db74">&#39;Simulated data&#39;</span>, y<span style="color:#f92672">=</span><span style="color:#ae81ff">1.05</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">22</span>, fontweight<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;semibold&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout()
</span></span></code></pre></div>


  




<figure>

  <a data-fancybox="" href="/img/kmeans/circles_right.png" >

<img src="/img/kmeans/circles_right.png" >
</a>

</figure>

<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<p>Kmeans clustering is one of the most popular clustering algorithms and usually the first thing practitioners apply when solving clustering tasks to get an idea of the structure of the dataset. The goal of kmeans is to group data points into distinct non-overlapping subgroups. It does a very good job when the clusters have a kind of spherical shapes. However, it suffers as the geometric shapes of clusters deviates from spherical shapes. Moreover, it also doesn&rsquo;t learn the number of clusters from the data and requires it to be pre-defined. To be a good practitioner, it&rsquo;s good to know the assumptions behind algorithms/methods so that you would have a pretty good idea about the strength and weakness of each method. This will help you decide when to use each method and under what circumstances. In this post, we covered both strength, weaknesses, and some evaluation methods related to kmeans.</p>
<p>Below are the main takeaways:</p>
<ul>
<li>Scale/standardize the data when applying kmeans algorithm.</li>
<li>Elbow method in selecting number of clusters doesn&rsquo;t usually work because the error function is monotonically decreasing for all $k$s.</li>
<li>Kmeans gives more weight to the bigger clusters.</li>
<li>Kmeans assumes spherical shapes of clusters (with radius equal to the distance between the centroid and the furthest data point) and doesn&rsquo;t work well when clusters are in different shapes such as elliptical clusters.</li>
<li>If there is overlapping between clusters, kmeans doesn&rsquo;t have an intrinsic measure for uncertainty for the examples belong to the overlapping region in order to determine for which cluster to assign each data point.</li>
<li>Kmeans may still cluster the data even if it can&rsquo;t be clustered such as data that comes from <em>uniform distributions</em>.</li>
</ul>
<p>The notebook that created this post can be found <a href="https://github.com/ImadDabbura/blog-posts/blob/master/notebooks/Kmeans-Clustering.ipynb">here</a>.</p>

    </div>

    


    

<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/data-science/">Data Science</a>
  
  <a class="badge badge-light" href="/tags/clustering/">Clustering</a>
  
  <a class="badge badge-light" href="/tags/machine-learning/">Machine Learning</a>
  
</div>



    
      








  





  
  
  
    
  
  
  <div class="media author-card" itemscope itemtype="http://schema.org/Person">
    
      
      <img class="portrait mr-3" src="/authors/admin/avatar_hu057a6ce318cedc9fff5e5d4bcb0cb87d_16356_250x250_fill_q90_lanczos_center.jpg" itemprop="image" alt="Avatar">
    

    <div class="media-body">
      <h5 class="card-title" itemprop="name"><a href="https://imaddabbura.github.io">Imad Dabbura</a></h5>
      <h6 class="card-subtitle">Senior Data Scientist</h6>
      <p class="card-text" itemprop="description">My interests include data science, machine learning and artificial intelligence.</p>
      <ul class="network-icon" aria-hidden="true">
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="/#contact" >
              <i class="fas fa-envelope"></i>
            </a>
          </li>
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="https://twitter.com/imadphd" target="_blank" rel="noopener">
              <i class="fab fa-twitter"></i>
            </a>
          </li>
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="//www.linkedin.com/in/imaddabbura" >
              <i class="fab fa-linkedin"></i>
            </a>
          </li>
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="https://github.com/imaddabbura" target="_blank" rel="noopener">
              <i class="fab fa-github"></i>
            </a>
          </li>
        
          
          
          
            
          
          
          
          
          
            
          
          <li>
            <a itemprop="sameAs" href="//medium.com/@ImadPhd" >
              <i class="fab fa-medium"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>



      
      
      <div class="article-widget">
        <div class="hr-light"></div>
        <h3>Related</h3>
        <ul>
          
          <li><a href="/post/pred-loan-repayment/">Predicting Loan Repayment</a></li>
          
          <li><a href="/post/gradient-descent-algorithm/">Gradient Descent Algorithm and Its Variants</a></li>
          
          <li><a href="/post/pred-employee-turnover/">Predicting Employee Turnover</a></li>
          
        </ul>
      </div>
      
    

    
    <div class="article-widget">
      
<div class="post-nav">
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">Next</div>
    <a href="/post/conda-essentials/" rel="next">Conda Essentials Notes</a>
  </div>
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">Previous</div>
    <a href="/post/coding-nn-dropout/" rel="prev">Coding Neural Network - Dropout</a>
  </div>
  
</div>

    </div>
    

    
<section id="comments">
  
    
<div id="disqus_thread"></div>
<script>
  let disqus_config = function () {
    
    
    
  };
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
      return;
    }
    var d = document, s = d.createElement('script'); s.async = true;
    s.src = 'https://' + "ImadDabbura" + '.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  
</section>



  </div>
</article>

      

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js" integrity="sha256-0w92bcB21IY5+rGI84MGj52jNfHNbXVeQLrZ0CGdjNY=" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/python.min.js"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.js" integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUupEVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log==" crossorigin="anonymous"></script>
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    <script id="dsq-count-scr" src="https://ImadDabbura.disqus.com/count.js" async></script>
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.9224c1df7774818c46d3c5196c37127b.js"></script>

    






  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    © Imad Dabbura 2018 &middot; 

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" id="back_to_top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
